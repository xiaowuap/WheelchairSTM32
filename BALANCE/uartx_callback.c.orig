#include "uartx_callback.h"
SEND_DATA Send_Data;
RECEIVE_DATA Receive_Data;
SEND_AutoCharge_DATA Send_AutoCharge_Data;
extern int Time_count;
u8 Flash_SaveFlag = 0;


/**************************************************************************
Function: Serial port 1 receives interrupted
Input   : none
Output  : none
函数功能：串口1接收中断
入口参数：无
返 回 值：无
**************************************************************************/
int USART1_IRQHandler(void)
{	
	static u8 Count=0;
	u8 Usart_Receive;

	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //Check if data is received //判断是否接收到数据
	{
		Usart_Receive = USART_ReceiveData(USART1);//Read the data //读取数据
		if(Time_count<CONTROL_DELAY)
			// Data is not processed until 25 seconds after startup
		  //开机25秒前不处理数据
			return 0;	//前期不进入中断
		
		//Fill the array with serial data
		//串口数据填入数组
    Receive_Data.buffer[Count]=Usart_Receive;
		
		//Ensure that the first data in the array is FRAME_HEADER
		//确保数组第一个数据为FRAME_HEADER
		if(Usart_Receive == FRAME_HEADER||Count>0) 
			Count++; 
		else 
			Count=0;
		
		if (Count == 11) //Verify the length of the packet //验证数据包的长度
		{   
				Count=0; //Prepare for the serial port data to be refill into the array //为串口数据重新填入数组做准备
				if(Receive_Data.buffer[10] == FRAME_TAIL) //Verify the frame tail of the packet //验证数据包的帧尾
				{
					//Data exclusionary or bit check calculation, mode 0 is sent data check
					//数据异或位校验计算，模式0是发送数据校验
					if(Receive_Data.buffer[9] ==Check_Sum(9,0))
				  {		
						float Vz;
						//Serial port 1 controls flag position 1, other flag position 0
						//串口1控制标志位置1，其它标志位置0
						PS2_ON_Flag=0;
						Remote_ON_Flag=0;
						APP_ON_Flag=0;
						CAN_ON_Flag=0;
						Usart_ON_Flag=1;
						command_lost_count=0;//串口、CAN控制命令丢失计数清零
					  
						//Calculate the target speed of three axis from serial data, unit m/s
						//从串口数据求三轴目标速度， 单位m/s
						Move_X=XYZ_Target_Speed_transition(Receive_Data.buffer[3],Receive_Data.buffer[4]);
						Move_Y=XYZ_Target_Speed_transition(Receive_Data.buffer[5],Receive_Data.buffer[6]);
						Vz=XYZ_Target_Speed_transition(Receive_Data.buffer[7],Receive_Data.buffer[8]);
						Move_Z=Vz_to_Akm_Angle(Move_X,Vz);
				  }
			}
		}
	} 
  return 0;
}
/**************************************************************************
Function: Refresh the OLED screen
Input   : none
Output  : none
函数功能：串口4接收中断
入口参数：无
返回  值：无
**************************************************************************/
int UART4_IRQHandler(void)
{	
	int Usart_Receive;
	if(USART_GetITStatus(UART4, USART_IT_RXNE) != RESET) //Check if data is received //判断是否接收到数据
	{	      
		static u8 Flag_PID,i,j,Receive[50],Last_Usart_Receive;
		static float Data;
				
		Usart_Receive=UART4->DR; //Read the data //读取数据
		
		_System_Reset_(Usart_Receive);
		
		if(Deviation_Count<CONTROL_DELAY)
			// Data is not processed until 10 seconds after startup
		  //开机10秒前不处理数据
		  return 0;	
		
		if(AT_Command_Capture(Usart_Receive)) return 1;
		
		if(Usart_Receive==0x41&&Last_Usart_Receive==0x41&&(Get_Control_Mode(_APP_Control))==0)
			//10 seconds after startup, press the forward button of APP to enter APP control mode
		  //The APP controls the flag position 1 and the other flag position 0
			//开机10秒之后，按下APP的前进键进入APP控制模式
			Set_Control_Mode(_APP_Control);
		
		Last_Usart_Receive=Usart_Receive;			
	  
		//Enter the APP steering control interface
		//进入APP转向控制界面
		if(Usart_Receive==0x4B) 
			appkey.TurnPage = 1;
	  else if(Usart_Receive==0x49||Usart_Receive==0x4A) 
			appkey.TurnPage = 0;	
		
		if( 1 == appkey.TurnPage ) 
		{
			//App rocker control interface command
			//APP摇杆控制界面命令
			if(Usart_Receive>=0x41&&Usart_Receive<=0x48)  
			{	
				appkey.DirectionFlag=Usart_Receive-0x40;
			}
			else	if(Usart_Receive<=8)   
			{			
				appkey.DirectionFlag=Usart_Receive;
			}	
			else  appkey.DirectionFlag=0;
		}
		else if(appkey.TurnPage==1)
		{
			//APP steering control interface command
			//APP转向控制界面命令
			if     (Usart_Receive==0x43) appkey.TurnFlag = 2; //Right rotation //右自转
			else if(Usart_Receive==0x47) appkey.TurnFlag = 1; //Left rotation  //左自转
			else                         appkey.TurnFlag = 0;
			
			if     (Usart_Receive==0x41||Usart_Receive==0x45) appkey.DirectionFlag=Usart_Receive-0x40;
			else  appkey.DirectionFlag=0;
		}
		
		if(Usart_Receive==0x58)  robot_control.rc_speed+=100; //Accelerate the keys, +100mm/s //加速按键，+100mm/s
		if(Usart_Receive==0x59)  robot_control.rc_speed-=100; //Slow down buttons,   -100mm/s //减速按键，-100mm/s
	  
	 // The following is the communication with the APP debugging interface
	 //以下是与APP调试界面通讯
	 if(Usart_Receive==0x7B) Flag_PID=1;   //The start bit of the APP parameter instruction //APP参数指令起始位
	 if(Usart_Receive==0x7D) Flag_PID=2;   //The APP parameter instruction stops the bit    //APP参数指令停止位
	
		if( Usart_Receive=='b' ) charger.AllowRecharge = !charger.AllowRecharge;
	else if(Usart_Receive=='m'  )
	{
		oled_page++;
		if(oled_page>OLED_MAX_PAGE) oled_page=1;
	}
		
	 if(Flag_PID==1) //Collect data //采集数据
	 {
		Receive[i]=Usart_Receive;
		i++;
	 }
	 if(Flag_PID==2) //Analyze the data //分析数据
	 {
			      if(Receive[3]==0x50) 	 appkey.ParamSendflag = 1; //发送数据到app显示
			else if( Receive[3]==0x57 ) appkey.ParamSaveFlag = 1; //保存参数到stm32 flash
			else  if(Receive[1]!=0x23) 
			{								
				for(j=i;j>=4;j--)
				{
					Data+=(Receive[j-1]-48)*pow(10,i-j);
				}
				switch(Receive[1])
				 {
					 case 0x30:  robot_control.rc_speed = Data ; break; //修改机器人的遥控速度
					 case 0x31:  PI_SetParam(&PI_MotorA,Data,-1); /* 使用-1代表相应的参数不设置 */
					              PI_SetParam(&PI_MotorB,Data,-1);
					              PI_SetParam(&PI_MotorC,Data,-1);
					              PI_SetParam(&PI_MotorD,Data,-1); 
					              break;
					 case 0x32:  PI_SetParam(&PI_MotorA,-1,Data);
								  PI_SetParam(&PI_MotorB,-1,Data);
								  PI_SetParam(&PI_MotorC,-1,Data);
								  PI_SetParam(&PI_MotorD,-1,Data);
								  break;
					 case 0x33:  robot_control.smooth_MotorStep = Data/1000 ; break;
					 case 0x34:  robot_control.smooth_ServoStep = Data ; break;
					 case 0x35:  Akm_Servo.Max=Data;break;
					 case 0x36:  Akm_Servo.Min=Data;break;
					 case 0x37:  Akm_Servo.Mid=Data;break;
					 case 0x38:  break; 	
				 }
			}
			else if( Receive[1]==0x23 ) //APP上点击“发送所有数据”处理方法
			{
				float num;
				u8 dataIndex=0;
				float dataArray[9];
				
				if( i<=50 ) //数据在可接受范围
				{
					Receive[i]='}'; //补充帧尾
					
					for(u8 kk=0;Receive[kk]!='}';kk++)
					{
						if( Receive[kk]>='0' && Receive[kk]<='9' )
						{
							num = num*10 + ( Receive[kk] - '0' );
						}
						else if( Receive[kk]==':' )
						{
							dataArray[dataIndex++] = num;
							num = 0;
						}
							
					}				
					//处理最后一个数据
					dataArray[dataIndex] = num;
					
					//数据赋值
					robot_control.rc_speed = dataArray[0];
					
					//kp、ki
					PI_SetParam(&PI_MotorA,dataArray[1],dataArray[2]);
					PI_SetParam(&PI_MotorB,dataArray[1],dataArray[2]);
					PI_SetParam(&PI_MotorC,dataArray[1],dataArray[2]);
					PI_SetParam(&PI_MotorD,dataArray[1],dataArray[2]);
					
					//速度平滑系数
					robot_control.smooth_MotorStep = dataArray[3]/1000;
					robot_control.smooth_ServoStep = dataArray[4];
					
					//阿克曼转向数据
					Akm_Servo.Max = dataArray[5];
					Akm_Servo.Min = dataArray[6];
					Akm_Servo.Mid = dataArray[7];
					
					//主动发送已修改的数据到app显示
					appkey.ParamSendflag=1;
				}
			}
			
		  //Relevant flag position is cleared			
		  //相关标志位清零			
			Flag_PID=0;
			i=0;
			j=0;
			Data=0;
			memset(Receive, 0, sizeof(u8)*50); //Clear the array to zero//数组清零
	 }
	 
	 //机器人遥控速度不可为负数
	if(robot_control.rc_speed<0)   robot_control.rc_speed=0; 	 
  }
  return 0;	
}
/**************************************************************************
Function: Serial port 3 receives interrupted
Input   : none
Output  : none
函数功能：串口3接收中断
入口参数：无
返回  值：无
**************************************************************************/
int USART3_IRQHandler(void)
{	
	static u8 Count=0;
	u8 Usart_Receive;

	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) //Check if data is received //判断是否接收到数据
	{
		Usart_Receive = USART_ReceiveData(USART3);//Read the data //读取数据
		if(Time_count<CONTROL_DELAY)
			// Data is not processed until 10 seconds after startup
		  //开机10秒前不处理数据
		  return 0;	
		
		//Fill the array with serial data
		//串口数据填入数组
    Receive_Data.buffer[Count]=Usart_Receive;
		
		// Ensure that the first data in the array is FRAME_HEADER
		//确保数组第一个数据为FRAME_HEADER
		if(Usart_Receive == FRAME_HEADER||Count>0) 
			Count++; 
		else 
			Count=0;
		
		if (Count == 11) //Verify the length of the packet //验证数据包的长度
		{   
				Count=0; //Prepare for the serial port data to be refill into the array //为串口数据重新填入数组做准备
				if(Receive_Data.buffer[10] == FRAME_TAIL) //Verify the frame tail of the packet //验证数据包的帧尾
				{
					//Data exclusionary or bit check calculation, mode 0 is sent data check
					//数据异或位校验计算，模式0是发送数据校验
					if(Receive_Data.buffer[9] ==Check_Sum(9,0))	 
				  {		
						float Vz;						//All modes flag position 0, USART3 control mode
						command_lost_count=0;//串口、CAN控制命令丢失计数清零
					  
						if(Receive_Data.buffer[1]==0)
						{
							Allow_Recharge=0;
							PS2_ON_Flag=0;
							Remote_ON_Flag=0;
							APP_ON_Flag=0;
							CAN_ON_Flag=0;
							Usart_ON_Flag=0;				
						 
							//Calculate the target speed of three axis from serial data, unit m/s
							//从串口数据求三轴目标速度， 单位m/s
							Move_X=XYZ_Target_Speed_transition(Receive_Data.buffer[3],Receive_Data.buffer[4]);
							Move_Y=XYZ_Target_Speed_transition(Receive_Data.buffer[5],Receive_Data.buffer[6]);
							Vz=XYZ_Target_Speed_transition(Receive_Data.buffer[7],Receive_Data.buffer[8]);
							Move_Z=Vz_to_Akm_Angle(Move_X,Vz);
						}
						else if( Receive_Data.buffer[1]==1 || Receive_Data.buffer[1]==2 )
						{
							Allow_Recharge=1; //开启自动回充
							
							if(Receive_Data.buffer[1]==2) nav_walk=1; //开启自动回充，上位机控制机器人	
							else nav_walk=0;
							
							//Calculate the target speed of three axis from serial data, unit m/s
							//从串口数据求三轴目标速度，单位m/s
							Recharge_UP_Move_X=XYZ_Target_Speed_transition(Receive_Data.buffer[3],Receive_Data.buffer[4]);
							Recharge_UP_Move_Y=XYZ_Target_Speed_transition(Receive_Data.buffer[5],Receive_Data.buffer[6]);
							Recharge_UP_Move_Z=XYZ_Target_Speed_transition(Receive_Data.buffer[7],Receive_Data.buffer[8]);	
							Recharge_UP_Move_Z = Vz_to_Akm_Angle(Recharge_UP_Move_X,Recharge_UP_Move_Z);
							
						}
						else if( Receive_Data.buffer[1]==3 )
						{
							//Set the speed of the infrared interconnection, unit m/s
							//设置红外对接的速度大小，单位m/s
							Red_Docker_X=XYZ_Target_Speed_transition(Receive_Data.buffer[3],Receive_Data.buffer[4]);
							Red_Docker_Y=XYZ_Target_Speed_transition(Receive_Data.buffer[5],Receive_Data.buffer[6]);
							Red_Docker_Z=XYZ_Target_Speed_transition(Receive_Data.buffer[7],Receive_Data.buffer[8]);	
						}
				  }
			}
		}
	} 
return 0;	
}

/**************************************************************************
Function: After the top 8 and low 8 figures are integrated into a short type data, the unit reduction is converted
Input   : 8 bits high, 8 bits low
Output  : The target velocity of the robot on the X/Y/Z axis
函数功能：将上位机发过来目标前进速度Vx、目标角速度Vz，转换为阿克曼小车的右前轮转角
入口参数：目标前进速度Vx、目标角速度Vz，单位：m/s，rad/s
返回  值：阿克曼小车的右前轮转角，单位：rad
**************************************************************************/
float Vz_to_Akm_Angle(float Vx, float Vz)
{
	float R, AngleR, Min_Turn_Radius;
	//float AngleL;
	
	//Ackermann car needs to set minimum turning radius
	//If the target speed requires a turn radius less than the minimum turn radius,
	//This will greatly improve the friction force of the car, which will seriously affect the control effect
	//阿克曼小车需要设置最小转弯半径
	//如果目标速度要求的转弯半径小于最小转弯半径，
	//会导致小车运动摩擦力大大提高，严重影响控制效果
	if(Car_Mode==0||Car_Mode==1||Car_Mode==7||Car_Mode==8||Car_Mode==9)
	{
		Min_Turn_Radius=SENIOR_AKM_MIN_TURN_RADIUS;
	}
	else if(Car_Mode==2||Car_Mode==3)
	{
		Min_Turn_Radius=TOP_AKM_BS_MIN_TURN_RADIUS;
	}
	else if(Car_Mode==4||Car_Mode==5)
	{
		Min_Turn_Radius=TOP_AKM_DL_MIN_TURN_RADIUS;
	}
	
	if(Vz!=0 && Vx!=0)
	{
		//If the target speed requires a turn radius less than the minimum turn radius
		//如果目标速度要求的转弯半径小于最小转弯半径
		if(float_abs(Vx/Vz)<=Min_Turn_Radius)
		{
			//Reduce the target angular velocity and increase the turning radius to the minimum turning radius in conjunction with the forward speed
			//降低目标角速度，配合前进速度，提高转弯半径到最小转弯半径
			if(Vz>0)
				Vz= float_abs(Vx)/(Min_Turn_Radius);
			else	
				Vz=-float_abs(Vx)/(Min_Turn_Radius);		
		}		
		R=Vx/Vz;
		//AngleL=atan(Axle_spacing/(R-0.5*Wheel_spacing));
		AngleR=atan(Axle_spacing/(R+0.5f*Wheel_spacing));
	}
	else
	{
		AngleR=0;
	}
	
	return AngleR;
}
/**************************************************************************
Function: After the top 8 and low 8 figures are integrated into a short type data, the unit reduction is converted
Input   : 8 bits high, 8 bits low
Output  : The target velocity of the robot on the X/Y/Z axis
函数功能：将上位机发过来的高8位和低8位数据整合成一个short型数据后，再做单位还原换算
入口参数：高8位，低8位
返回  值：机器人X/Y/Z轴的目标速度
**************************************************************************/
float XYZ_Target_Speed_transition(u8 High,u8 Low)
{
	//Data conversion intermediate variable
	//数据转换的中间变量
	short transition; 
	
	//将高8位和低8位整合成一个16位的short型数据
	//The high 8 and low 8 bits are integrated into a 16-bit short data
	transition=((High<<8)+Low); 
	return 
		transition/1000+(transition%1000)*0.001; //Unit conversion, mm/s->m/s //单位转换, mm/s->m/s	
}

/**************************************************************************
Function: The current XYZ three axis velocity of the robot is calculated from the data of the encoder
Input   : Data from various encoders
Output  : none
函数功能：通过编码器的数据计算机器人当前的XYZ三轴速度
入口参数：各路编码器的数据
返回  值：无
**************************************************************************/
#if Mec
void Motion_analysis_transformation(float Encoder_A,float Encoder_B,float Encoder_C,float Encoder_D)
{
	Send_Data.Sensor_Str.X_speed = ((Encoder_A+Encoder_B+Encoder_C+Encoder_D)/4)*1000; 
	Send_Data.Sensor_Str.Y_speed = ((Encoder_A-Encoder_B+Encoder_C-Encoder_D)/4)*1000; 
	Send_Data.Sensor_Str.Z_speed = ((-Encoder_A-Encoder_B+Encoder_C+Encoder_D)/4/(Axle_spacing+Wheel_spacing))*1000;
}
#elif Omni
void Motion_analysis_transformation(float Encoder_A,float Encoder_B,float Encoder_C)
{
	Send_Data.Sensor_Str.X_speed = ((Encoder_C-Encoder_B)/2/X_PARAMETER)*1000;
	Send_Data.Sensor_Str.Y_speed = ((Encoder_A*2-Encoder_B-Encoder_C)/3)*1000; 
	Send_Data.Sensor_Str.Z_speed = ((Encoder_A+Encoder_B+Encoder_C)/3/Omni_turn_radiaus)*1000;
}
#endif

/**************************************************************************
Function: Calculates the check bits of data to be sent/received
Input   : Count_Number: The first few digits of a check; Mode: 0-Verify the received data, 1-Validate the sent data
Output  : Check result
函数功能：计算要发送/接收的数据校验结果
入口参数：Count_Number：校验的前几位数；Mode：0-对接收数据进行校验，1-对发送数据进行校验
返回  值：校验结果
**************************************************************************/
u8 Check_Sum(unsigned char Count_Number,unsigned char Mode)
{
	unsigned char check_sum=0,k;
	
	//Validate the data to be sent
	//对要发送的数据进行校验
	if(Mode==1)
	for(k=0;k<Count_Number;k++)
	{
	check_sum=check_sum^Send_Data.buffer[k];
	}
	
	//Verify the data received
	//对接收到的数据进行校验
	if(Mode==0)
	for(k=0;k<Count_Number;k++)
	{
	check_sum=check_sum^Receive_Data.buffer[k];
	}
	return check_sum;
}



//蓝牙AT指令抓包，防止指令干扰到机器人正常的蓝牙通信
u8 AT_Command_Capture(u8 uart_recv)
{
	/*
	蓝牙链接时发送的字符，00:11:22:33:44:55为蓝牙的MAC地址
	+CONNECTING<<00:11:22:33:44:55\r\n
	+CONNECTED\r\n
	共44个字符
	
	蓝牙断开时发送的字符
	+DISC:SUCCESS\r\n
	+READY\r\n
	+PAIRABLE\r\n
	共34个字符
	\r -> 0x0D
	\n -> 0x0A
	*/
	
	static u8 pointer = 0; //蓝牙接受时指针记录器
	static u8 bt_line = 0; //表示现在在第几行
	static u8 disconnect = 0;
	static u8 connect = 0;
	
	//断开连接
	static char* BlueTooth_Disconnect[3]={"+DISC:SUCCESS\r\n","+READY\r\n","+PAIRABLE\r\n"};
	
	//开始连接
	static char* BlueTooth_Connect[2]={"+CONNECTING<<00:00:00:00:00:00\r\n","+CONNECTED\r\n"};


	//特殊标识符，开始警惕(使用时要-1)
	if(uart_recv=='+') 
	{
		bt_line++,pointer=0; //收到‘+’，表示切换了行数	
		disconnect++,connect++;
		return 1;//抓包，禁止控制
	}

	if(bt_line!=0) 
	{	
		pointer++;

		//开始追踪数据是否符合断开的特征，符合时全部屏蔽，不符合时取消屏蔽
		if(uart_recv == BlueTooth_Disconnect[bt_line-1][pointer])
		{
			disconnect++;
			if(disconnect==34) disconnect=0,connect=0,bt_line=0,pointer=0;
			return 1;//抓包，禁止控制
		}			

		//追踪连接特征 (bt_line==1&&connect>=13)区段是蓝牙MAC地址，每一个蓝牙MAC地址都不相同，所以直接屏蔽过去
		else if(uart_recv == BlueTooth_Connect[bt_line-1][pointer] || (bt_line==1&&connect>=13) )
		{		
			connect++;
			if(connect==44) connect=0,disconnect=0,bt_line=0,pointer=0;		
			return 1;//抓包，禁止控制
		}	

		//在抓包期间收到其他命令，停止抓包
		else
		{
			disconnect = 0;
			connect = 0;
			bt_line = 0;		
			pointer = 0;
			return 0;//非禁止数据，可以控制
		}			
	}
	
	return 0;//非禁止数据，可以控制
}



//软复位进BootLoader区域
void _System_Reset_(u8 uart_recv)
{
	static u8 res_buf[5];
	static u8 res_count=0;
	
	res_buf[res_count]=uart_recv;
	
	if( uart_recv=='r'||res_count>0 )
		res_count++;
	else
		res_count = 0;
	
	if(res_count==5)
	{
		res_count = 0;
		//接受到上位机请求的复位字符“reset”，执行软件复位
		if( res_buf[0]=='r'&&res_buf[1]=='e'&&res_buf[2]=='s'&&res_buf[3]=='e'&&res_buf[4]=='t' )
		{
			NVIC_SystemReset();//进行软件复位，复位后执行 BootLoader 程序
		}
	}
}

//自动回充发送字节专用校验函数
u8 Check_Sum_AutoCharge(unsigned char Count_Number,unsigned char Mode)
{
	unsigned char check_sum=0,k;
	
	//Validate the data to be sent
	//对要发送的数据进行校验
	if(Mode==1)
	for(k=0;k<Count_Number;k++)
	{
	check_sum=check_sum^Send_AutoCharge_Data.buffer[k];
	}
	
	return check_sum;	
}


